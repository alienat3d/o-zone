/* import getData from './get-data.js';
import renderGoods from './render-goods.js';
import { searchFilter } from './filters.js'; */

const search = () => {
  // 1.1 Получим строку ввода поиска
  const searchInput = document.querySelector('.search-wrapper_input');
  // 1.2 Повесим обработчик события по событию ввода какой-то информации.
  searchInput.addEventListener('input', (evt) => {
    // 1.3 В объекте событий event есть много полезных свойств, например target, у которого также есть свойство value, которое содержит введённую в поиск строку и нам очень пригодится.
    // 1.4 Теперь в отдельную переменную получим value этого элемента
    const value = evt.target.value;
    // 1.5.1 Зачастую на практике мы отправляем при каждом вводе запрос с определённым query-параметром на сервер, который выбирает этот query-параметр и на его основе возвращает нам определённые элементы. Для этого возьмём из load.js получение и отрисовку данных.
    // ? 1.5.2 (см. get-data.js) Довольно часто value как раз передают в модуль getData. В модуле getData в запрос fetch обычно делают через интерполяцию и после URL ставят ?${string ? `search=${string}` : ''}, а аргументом в getData будет "string". Таким образом метод getData() перед отправкой fetch() при помощи тернарного оператора проверит существует ли переданный параметр и если его нет, то ничего добавляться не будет. Но если он существует, то мы добавим search=(переданной строке). Сервер примет данный URL уже с параметром, на своей стороне обработает все данные и отдаст нам только те элементы, где присутствуют совпадения с этой строкой. Как это работает более наглядно можно посмотреть в DevTools -> Network.
    // ? 1.5.3 К сожалению Firebase не очень умеет работать с подобной схемой, описанной выше, но JSON Server отлично умеет! С ним можно работать, как с полноценным RestAPI.
    // ? 1.5.4 Firebase же не считается полноценным RestAPI, поэтому нам придётся действовать иначе.
    // 1.5.5 Мы будем получать весь массив товаров и отфильтровывать его по значению value.
    getData().then((data) => {
      // 1.6 В функцию renderGoods() у нас теперь уйдёт обработанная функцией searchFilter() data.
      renderGoods(searchFilter(data, value));
    });
  });
};

// export default search;
