// === Специальная функция-помощник «Debounce», которая позволяет создавать отложенные запросы на сервер, предотвращая возможные перегрузки сервера запросами, если их будет слишком много. ===
// 1.1 Она будет принимать два параметра «func», некая функция, которую мы будем отложено делать и «ms» - миллисекунды, т.е. количество времени сколько у нас будет копиться введённая информация для отправки на сервер. Т.е. если в промежутке между вводом одного символа до другого не прошло указанное количество миллисекунд, то запрос на сервер откладывается, пока промежуток между вводом не станет достаточно долгим. И поставим значение по умолчанию 500.
export const debounce = (func, ms = 500) => {
  // 1.2 Делаем time, т.е. некую переменную, в которой у нас будет производится отсчёт времени.
  let timer;
  // 1.3 Далее наша функция при вызове будет возвращать другую функцию. Т.е. вызываем мы функцию debounce, но возвращаем некую callback-функцию, который возьмёт все параметры функции.
  return (...args) => {
    // 1.4 Почистит таймер, который мы используем по идентификатору timer
    clearTimeout(timer);
    // 1.5 Создаёт новый таймер, который вызывает функцию setTimeout() с callback-функцией func-apply(), куда передаём контекст вызова this и все параметры.
    // 1.6 А через запятую укажем время таймаута из нашего определённого значения «ms».
    timer = setTimeout(() => {func.apply(this, args)}, ms);
  };
};

// 1.7 Итак, что же там выше происходит? Когда мы вызываем функцию поиска - она попадает в функцию debounce(), запускается некий таймер на 500 миллисекунд. И если в течении этих 500 мс мы ещё раз введём какой-то символ, то у нас снова запустится debounce(), почистит предыдущий таймер и запустит новый. Таким образом, если мы достаточно быстро печатаем, то у нас не будет происходить вызов функции при каждом вводе символа, как это было прежде.
// 1.8 Теперь пришло время перейти в search.js и воспользоваться той функцией-хелпером.